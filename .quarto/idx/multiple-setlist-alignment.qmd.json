{"title":"Multiple Setlist Alignment","markdown":{"yaml":{"title":"Multiple Setlist Alignment","author":"Hans van Leeuwen","editor":"visual"},"headingText":"Tour set-list alignment","containsRefs":false,"markdown":"\n\n\nNow we can dig a bit deeper, and see which songs are actually played in the set-lists of the shows within a tour. The alignment plots below shows a first attempt of aligning setlists for each tour. It takes the 30 most representative shows for a tour, and then uses an alignment method to display the variation (or not) of songs played during the shows. The code handles insertions and deletions in the set-list sequences, similar to how DNA sequence alignment algorithms handle gaps. It uses dynamic programming to implement a variant of the [@Murata1990]Needleman-Wunsch algorithm.\n\nI have spent quite some time in experimenting with other biological sequence algorithms applied to this concert tour set-list alignment topic. For example, the [@Thompson2002]CLUSTALW algorithms for multiple sequence alignment. The main challenge was to convert the non-biological sequence of a set-list to a biological sequence which is required for such algorithms. In the end I decided to just leave it as it is with the below implemented code, but this could be a topic to investigate further.\n\nIn the plots below you can very well see the conserved blocks of the show, as well as the moments when there is more variability in the song they play each night.\n\nI also created an interactive Shiny app for this where you can select the tour of interest. See more info on the page [Interactive Visualizations](interactive-visual-apps.qmd#tour-setlist-alignment-with-interactive-tour-filter-using-shiny).\n\nFirst we load my custom concertData package where I organized all the functions to analyze the U2 concert data.\n\n```{r load custom concertData package, message = FALSE, warning = FALSE}\ndevtools::load_all(\"../packages/concertData\")\nlibrary(concertData)\n```\n\nLoad the u2data file.\n\n```{r data analysis - load libraries, message = FALSE, warning = FALSE}\n\n# read the u2 concertData\nu2data <- read_concertData_csv('u2data/u2data_all_shows_clean_final.csv')\n```\n\n```{r data analysis - tour setlist alignment NW, warning=FALSE, message=FALSE, error=FALSE, out.width=\"100%\" }\n\n# Filter for specific tour\ntour_data <- u2data[u2data$tour == \"U2 Vertigo Tour\", ]\n# Remove snippets\nno_snippets_data <- concertData_remove_snippets(tour_data)\n# Remove shows with no setlist \nfiltered_data <- concertData_remove_showsNoSetlist(no_snippets_data)\n\n# Process the songs to create the mapping of codes\ncodes_tour_songs <- codify_tour_song_titles(filtered_data)\n\n# create alignments using a customly written multiple setlist aligment code\n# following the pairwise alignment approach of the Needleman-Wunsch algorithm\naligned_setlists <- create_setlist_alignment(filtered_data, max_shows = 30)\n\n# create alignment data frame for downstream vizualisation\nalignment_data <- format_alignment_data(aligned_setlists, codes_tour_songs, filtered_data)\n\n# get number of shows in the alignment\nnum_setlists <- length(unique(alignment_data$showID))\n\n# Mapping the sequence characters to the tour_song_codes\nsong_code_lookup <- codes_tour_songs[, c(\"hex_char\", \"four_letter_code\", \"song_title\")]\n\n# create vizualisation data object\nviz_data <- create_setlist_viz_data(alignment_data, song_code_lookup, filtered_data)\n\n# Create legend for acronyms/short titles\nlegend_data <- viz_data[!viz_data$is_gap, c(\"song_title\", \"four_letter_code\")]\nlegend_data <- unique(legend_data)\nlegend_data <- legend_data[order(legend_data$song_title), ]\nlegend_text <- paste(legend_data$four_letter_code, \"=\", legend_data$song_title, collapse = \", \")\n\n# Create custom color scale that uses distinct colors for songs and white for gaps\nn_songs <- length(unique(viz_data$song_title[!viz_data$is_gap]))\nsong_colors <- create_distinct_palette(n_songs)\nnames(song_colors) <- unique(viz_data$song_title[!viz_data$is_gap])\nsong_colors <- c(song_colors, GAP = \"white\")\n\n# Get the tour name from filtered_data\n# Get a single showID from alignment_data\nsample_showID <- alignment_data$showID[1]\n# Lookup the tour_name in filtered_data\ntour_name <- unique(filtered_data$tour[filtered_data$showID == sample_showID])\n\n# plot the multiple sequence alignment of the tour setlists\n# load library\nlibrary(ggplot2)\nlibrary(gridExtra)\nlibrary(stringr)\n\n# Create a new column combining city and date\nviz_data$city_date <- paste(viz_data$city, \"-\", as.character(viz_data$date))\n\n# Create a unique identifier for each show\nviz_data$show_id <- seq_len(nrow(viz_data))\n\n# Convert city_date to a factor based on the original order in viz_data\nviz_data$city_date <- factor(viz_data$city_date, levels = unique(viz_data$city_date[viz_data$show_id]))\n\n# Create main plot\nmain_plot <- ggplot(viz_data, aes(x = position, y = city_date)) +\n  geom_tile(aes(fill = song_title), color = \"grey90\", linewidth = 0.5) +\n  geom_text(aes(label = ifelse(is_gap, \"\", four_letter_code)), \n            size = 1.5,\n            color = \"white\") +\n  scale_fill_manual(values = song_colors) +\n  theme_minimal() +\n  theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 7),\n        axis.text.y = element_text(size = 8),\n        plot.title = element_text(size = 12, hjust = 0.5),\n        plot.subtitle = element_text(size = 10, hjust = 0.5),\n        legend.position = \"none\",\n        panel.grid = element_blank()) +\n  labs(x = \"Song Position\", y = \"City - Show Date\",\n       title = paste(\"Setlist Alignment for\", tour_name),\n       subtitle = paste(\"Showing\", num_setlists, \"most representative setlists. Empty white cells indicate inserted/skipped songs\")\n  )\n\n# Create legend plot\nlegend_plot <- ggplot() +\n  geom_text(aes(x = 0.5, y = 0.5, label = str_wrap(legend_text, width = 250)), \n           size = 2, hjust = 0.5) +\n  theme_void() + \n  theme(plot.margin = margin(t = 10))\n\n# Arrange plots together\ngrid.arrange(main_plot,\n             legend_plot,\n             ncol = 1,\n             heights = c(4, 1))\n\n```\n\n## Multiple Setlist Alignment with MAFFT\n\nI was not satisfied with the resulting alignments shown above, produced with the custom alignment code based on the Needleman-Wunsch algorithm. While exploring alternatives I discovered that the [@Katoh2002]MAFFT algorithm for multiple sequence alignment has an option '--text' mode that can calculate and create multiple sequence alignments for non-biological sequences (see [this page](https://mafft.cbrc.jp/alignment/software/textcomparison.html) from the MAFFT authors). In the R package ips there is a [mafft wrapper function](https://search.r-project.org/CRAN/refmans/ips/html/mafft.html), so I installed and tried it out. However, this R implementation of mafft does not allow for the `--text` mode. Hence, I implemented the solution using both R and the command line version of mafft on my Mac. I could also wrap the command line actions and execute it from R, but I did not spend time on that, mainly because it would still create a challenging dependency in my R-package.\n\n```{r data analysis - tour setlist alignment MAFFT, warning=FALSE, message=FALSE, error=FALSE}\n\n# Filter for specific tour\ntour_data <- u2data[u2data$tour == \"U2 Vertigo Tour\", ]\n# Remove snippets\nno_snippets_data <- concertData_remove_snippets(tour_data)\n# Remove shows with no setlist \nfiltered_data <- concertData_remove_showsNoSetlist(no_snippets_data)\n\n# Process the songs to create the mapping of codes\ncodes_tour_songs <- codify_tour_song_titles(filtered_data)\n\n# Prepare all setlist sequences\nall_setlist_sequences <- prepare_setlist_sequences(filtered_data, codes_tour_songs)\n\n# Find the most representative setlists\nrepresentative_setlists <- find_most_representative_setlists(all_setlist_sequences, n_representatives = 30)\n\n# Create fasta-format sequences representing the set-lists of the representative shows\nfasta_mafft_output <- create_setlist_fasta_mafft(representative_setlists)\nwriteLines(fasta_mafft_output, \"mafft/u2_setlists.hex\")\n\n```\n\nNow we have the FASTA-like file with hex values that we can use as input for the multiple sequence alignment algorithm MAFFT. See explanation for this text mode version (non-biological sequences alignment) at: https://mafft.cbrc.jp/alignment/software/textcomparison.html\n\nFollowing the flow explained there, we convert the HEX file to ASCII code using the hex2mafftext command:\n\n``` bash\nhex2maffttext u2_setlists.hex > u2_setlists.ASCII\n```\n\nThe resulting file looks like:\n\n```         \nhead u2_setlists.ASCII\n>showID1392\n,Q9R87,HL9M8CKVJMNf8I^_\n>showID1408\n,Q9NM7,HL9M8CKVJROf8I^_\n>showID1328\n,Q9E87,HL9M8CKVJG7f8I^_\n>showID1320\n,Q9887,HL9M8CKVJGYf8I^_\n>showID1325\n,Q9E87,HL9M8CKVJROf8I+^_\n```\n\nThen we run the actual multiple sequence alignment with the command:\n\n``` bash\nmafft --text --clustalout u2_setlists.ASCII > u2_setlists_mafft_alignment.ASCII\n```\n\nThe output of the run:\n\n```         \nnthread = 0\nnthreadpair = 0\nnthreadtb = 0\nppenalty_ex = 0\nstacksize: 8192 kb\nnalphabets = 256\nGap Penalty = -1.53, +0.00, +0.00\n\n\n\nMaking a distance matrix ..\n    1 / 30\ndone.\n\nConstructing a UPGMA tree (efffree=0) ... \n   20 / 30\ndone.\n\nProgressive alignment 1/2... \nSTEP    20 / 29  d\nReallocating..done. *alloclen = 1048\nSTEP    29 / 29  h\ndone.\n\nMaking a distance matrix from msa.. \n    0 / 30\ndone.\n\nConstructing a UPGMA tree (efffree=1) ... \n   20 / 30\ndone.\n\nProgressive alignment 2/2... \nSTEP    28 / 29  d\nReallocating..done. *alloclen = 1048\nSTEP    29 / 29  h\ndone.\n\ndisttbfast (text) Version 7.526\nalg=A, model=Extended, 1.53, -0.00, -0.00, noshift, amax=0.0\n0 thread(s)\n\n\nStrategy:\n NW-NS-2 (Fast but rough)\n Progressive method (guide trees were built 2 times.)\n\nIf unsure which option to use, try 'mafft --auto input > output'.\nFor more information, see 'mafft --help', 'mafft --man' and the mafft page.\n\nThe default gap scoring scheme has been changed in version 7.110 (2013 Oct).\nIt tends to insert more gaps into gap-rich regions than previous versions.\nTo disable this change, add the --leavegappyregion option\n```\n\nThe output sequence alignment file looks like this:\n\n```         \nmore u2_setlists_mafft_alignment.ASCII\nCLUSTAL format alignment by MAFFT NW-NS-2 (v7.526)\n\n\nshowID1392      -,Q9R-87,HL9M8CKVJMN-f8I^_-\nshowID1408      -,Q9N-M7,HL9M8CKVJRO-f8I^_-\nshowID1328      -,Q9E-87,HL9M8CKVJG7-f8I^_-\nshowID1320      -,Q98-87,HL9M8CKVJ-GYf8I^_-\nshowID1325      -,Q9E-87,HL9M8CKVJRO-f8I+^_\nshowID1299      -,Q9D-8,-HL9M8\\KVJRO-Nf8^_-\nshowID1286      -,Q9R-88,HL9M8\\KVJRO-N8^_--\nshowID1282      -,Q9R-8,-HL9M8\\KVJRO-N8^_--\nshowID1339      -,Q9E--7,UL9M8CKVJMN-f7I^_-\nshowID1412      -,Q9D--7,UL9M8CKVJMN-f7I^_-\nshowID1327      -,Q9E-87,HL9M8CKVJ(--f8^_--\nshowID1271      QE899-,7,HL9M8CKVJRO-f8^_--\nshowID1267      QE899-,7,HL9M8CKVJRO-f8Q--\nshowID1269      QE899-,7,HL9M8CKVJRO-f8Q--\nshowID1270      QE899-,7,HL9M8CKVJRO-f8Q--\nshowID1393      -,Q9E-87,UL9M8CKVJMO-f8\\+-\nshowID1321      -,Q98-87,HL9M8CKVJLGYf8I^_-\nshowID1331      -,Q9E887,HL9M8CKVJ\\7-f8I^_-\nshowID1330      -,Q9E-87,HL9M8CKVJG7Bf8I^_-\nshowID1336      -,Q9N-M7,HL9M8CKVJ7Y-f8I^_-\nshowID1329      -,Q9-8@7,HL9M8CKVJ\\Y-f8+--\nshowID1259      QE89,-77,HL9M8CKVJRO-f8Q--\nshowID1266      QE899-,7,HL9M8CKVJRO-f8BQ-\nshowID1289      QE899-,7,HL9M8CKVJRO-f8BQ-\nshowID1435      -,Q9E--9,DL9M8CKVJON-f8%:-\nshowID1281      -,Q9R-8,9HL9M8\\KVJRO-N8^_--\nshowID1305      -,Q9R-8,9HL9M8\\KVJRO-N8^_--\nshowID1436      -,Q9E-9,7%L9M8CKVJRO-f82:-\nshowID1322      -,Q988F7,HL9M8CKVJG7-f8^_--\nshowID1284      -,Q9D-8,-HL9M8\\KVJRO-N87+-\n                   *      **** ***        \n```\n\nNow we can visualize this multiple set list alignment.\n\n```{r data analysis - tour setlist alignment MAFFT - plot, warning=FALSE, message=FALSE, error=FALSE}\n\n# libraries\nlibrary(dplyr)\nlibrary(stringr)\n\n# Get a data frame from the mafft clustal output\nalignment_data <- read_mafft_clustal_alignment(\"mafft/u2_setlists_mafft_alignment.ASCII\")\n\n# get number of shows in the alignment\nnum_setlists <- length(unique(alignment_data$showID))\n\n# Mapping the sequence characters to the tour_song_codes\nsong_code_lookup <- codes_tour_songs[, c(\"hex_char\", \"four_letter_code\", \"song_title\")]\n\n# create vizualisation data object\nviz_data <- create_setlist_viz_data(alignment_data, song_code_lookup, filtered_data)\n\n# Create legend for acronyms/short titles\nlegend_data <- viz_data[!viz_data$is_gap, c(\"song_title\", \"four_letter_code\")]\nlegend_data <- unique(legend_data)\nlegend_data <- legend_data[order(legend_data$song_title), ]\nlegend_text <- paste(legend_data$four_letter_code, \"=\", legend_data$song_title, collapse = \", \")\n\n# Create custom color scale that uses distinct colors for songs and white for gaps\nn_songs <- length(unique(viz_data$song_title[!viz_data$is_gap]))\nsong_colors <- create_distinct_palette(n_songs)\nnames(song_colors) <- unique(viz_data$song_title[!viz_data$is_gap])\nsong_colors <- c(song_colors, GAP = \"white\")\n\n# Get the tour name from filtered_data\n# Get a single showID from alignment_data\nsample_showID <- alignment_data$showID[1]\n# Lookup the tour_name in filtered_data\ntour_name <- unique(filtered_data$tour[filtered_data$showID == sample_showID])\n\n# plot the multiple sequence alignment of the tour setlists\n# load library\nlibrary(ggplot2)\nlibrary(gridExtra)\n\n# Create a new column combining city and date\nviz_data$city_date <- paste(viz_data$city, \"-\", as.character(viz_data$date))\n\n# Create a unique identifier for each show\nviz_data$show_id <- seq_len(nrow(viz_data))\n\n# Convert city_date to a factor based on the original order in viz_data\nviz_data$city_date <- factor(viz_data$city_date, levels = unique(viz_data$city_date[viz_data$show_id]))\n\n# Create main plot\nmain_plot <- ggplot(viz_data, aes(x = position, y = city_date)) +\n  geom_tile(aes(fill = song_title), color = \"grey90\", linewidth = 0.5) +\n  geom_text(aes(label = ifelse(is_gap, \"\", four_letter_code)), \n            size = 1.5,\n            color = \"white\") +\n  scale_fill_manual(values = song_colors) +\n  theme_minimal() +\n  theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 7),\n        axis.text.y = element_text(size = 8),\n        plot.title = element_text(size = 12, hjust = 0.5),\n        plot.subtitle = element_text(size = 10, hjust = 0.5),\n        legend.position = \"none\",\n        panel.grid = element_blank()) +\n  labs(x = \"Song Position\", y = \"City - Show Date\",\n       title = paste(\"Setlist Alignment for\", tour_name),\n       subtitle = paste(\"Showing\", num_setlists, \"most representative setlists. Empty white cells indicate inserted/skipped songs\")\n  )\n\n# Create legend plot\nlegend_plot <- ggplot() +\n  geom_text(aes(x = 0.5, y = 0.5, label = str_wrap(legend_text, width = 250)), \n           size = 2, hjust = 0.5) +\n  theme_void() + \n  theme(plot.margin = margin(t = 10))\n\n# Arrange plots together\ngrid.arrange(main_plot,\n             legend_plot,\n             ncol = 1,\n             heights = c(4, 1))\n```\n\n## Distance tree of aligned setlists\n\nAnother way to display the relatedness of setlists is to use a distance tree, often used for biological sequences, producing so called phylogenetic trees.\n\n```{r data analysis - tour setlist distance tree, warning=FALSE, message=FALSE, error=FALSE}\n\nlibrary(dplyr)\nlibrary(seqinr)\nlibrary(ape)\nlibrary(ggplot2)\nlibrary(ggtree)\n\n# Get a data frame from the mafft clustal output\nalignment_data <- read_mafft_clustal_alignment(\"mafft/u2_setlists_mafft_alignment.ASCII\")\n# Convert data frame to list which is needed for downstream distance tree analysis\nsequences <- setNames(as.list(alignment_data$sequence), paste0(\"showID\", alignment_data$showID))\n\n# Calculate distance matrix\ndist_matrix <- calculate_distance_matrix(sequences)\n# Convert to dist object\nsetlist_dist <- as.dist(dist_matrix)\n# Construct the tree\nsetlist_tree <- nj(setlist_dist)\n\n# Collect show info\nshow_info <- unique(filtered_data[, c(\"showID\", \"city\", \"date\", \"country\", \"leg\")])\nshow_info$city_date <- paste(show_info$city, format(show_info$date, \"%Y-%m-%d\"), sep = \" - \")\n\n# create tree labels in the format 'City YYYY-MM-DD'\nnew_labels <- create_city_date_tree_labels(filtered_data, setlist_tree, show_info)\n# Modify tree labels \nsetlist_tree$tip.label <- new_labels\n\n# create standard tree plot\ntree_plot <- create_ggtree_plot(setlist_tree)\n# Display the plot\nprint(tree_plot)\n\n# Create the tree plot with colors based on country\nplot_country <- create_ggtree_plot_colored(setlist_tree, show_info, color_by = \"country\")\nprint(plot_country)\n\n# Create the tree plot with colors based on leg\nplot_leg <- create_ggtree_plot_colored(setlist_tree, show_info, color_by = \"leg\")\nprint(plot_leg)\n\n```\n","srcMarkdownNoYaml":"\n\n## Tour set-list alignment\n\nNow we can dig a bit deeper, and see which songs are actually played in the set-lists of the shows within a tour. The alignment plots below shows a first attempt of aligning setlists for each tour. It takes the 30 most representative shows for a tour, and then uses an alignment method to display the variation (or not) of songs played during the shows. The code handles insertions and deletions in the set-list sequences, similar to how DNA sequence alignment algorithms handle gaps. It uses dynamic programming to implement a variant of the [@Murata1990]Needleman-Wunsch algorithm.\n\nI have spent quite some time in experimenting with other biological sequence algorithms applied to this concert tour set-list alignment topic. For example, the [@Thompson2002]CLUSTALW algorithms for multiple sequence alignment. The main challenge was to convert the non-biological sequence of a set-list to a biological sequence which is required for such algorithms. In the end I decided to just leave it as it is with the below implemented code, but this could be a topic to investigate further.\n\nIn the plots below you can very well see the conserved blocks of the show, as well as the moments when there is more variability in the song they play each night.\n\nI also created an interactive Shiny app for this where you can select the tour of interest. See more info on the page [Interactive Visualizations](interactive-visual-apps.qmd#tour-setlist-alignment-with-interactive-tour-filter-using-shiny).\n\nFirst we load my custom concertData package where I organized all the functions to analyze the U2 concert data.\n\n```{r load custom concertData package, message = FALSE, warning = FALSE}\ndevtools::load_all(\"../packages/concertData\")\nlibrary(concertData)\n```\n\nLoad the u2data file.\n\n```{r data analysis - load libraries, message = FALSE, warning = FALSE}\n\n# read the u2 concertData\nu2data <- read_concertData_csv('u2data/u2data_all_shows_clean_final.csv')\n```\n\n```{r data analysis - tour setlist alignment NW, warning=FALSE, message=FALSE, error=FALSE, out.width=\"100%\" }\n\n# Filter for specific tour\ntour_data <- u2data[u2data$tour == \"U2 Vertigo Tour\", ]\n# Remove snippets\nno_snippets_data <- concertData_remove_snippets(tour_data)\n# Remove shows with no setlist \nfiltered_data <- concertData_remove_showsNoSetlist(no_snippets_data)\n\n# Process the songs to create the mapping of codes\ncodes_tour_songs <- codify_tour_song_titles(filtered_data)\n\n# create alignments using a customly written multiple setlist aligment code\n# following the pairwise alignment approach of the Needleman-Wunsch algorithm\naligned_setlists <- create_setlist_alignment(filtered_data, max_shows = 30)\n\n# create alignment data frame for downstream vizualisation\nalignment_data <- format_alignment_data(aligned_setlists, codes_tour_songs, filtered_data)\n\n# get number of shows in the alignment\nnum_setlists <- length(unique(alignment_data$showID))\n\n# Mapping the sequence characters to the tour_song_codes\nsong_code_lookup <- codes_tour_songs[, c(\"hex_char\", \"four_letter_code\", \"song_title\")]\n\n# create vizualisation data object\nviz_data <- create_setlist_viz_data(alignment_data, song_code_lookup, filtered_data)\n\n# Create legend for acronyms/short titles\nlegend_data <- viz_data[!viz_data$is_gap, c(\"song_title\", \"four_letter_code\")]\nlegend_data <- unique(legend_data)\nlegend_data <- legend_data[order(legend_data$song_title), ]\nlegend_text <- paste(legend_data$four_letter_code, \"=\", legend_data$song_title, collapse = \", \")\n\n# Create custom color scale that uses distinct colors for songs and white for gaps\nn_songs <- length(unique(viz_data$song_title[!viz_data$is_gap]))\nsong_colors <- create_distinct_palette(n_songs)\nnames(song_colors) <- unique(viz_data$song_title[!viz_data$is_gap])\nsong_colors <- c(song_colors, GAP = \"white\")\n\n# Get the tour name from filtered_data\n# Get a single showID from alignment_data\nsample_showID <- alignment_data$showID[1]\n# Lookup the tour_name in filtered_data\ntour_name <- unique(filtered_data$tour[filtered_data$showID == sample_showID])\n\n# plot the multiple sequence alignment of the tour setlists\n# load library\nlibrary(ggplot2)\nlibrary(gridExtra)\nlibrary(stringr)\n\n# Create a new column combining city and date\nviz_data$city_date <- paste(viz_data$city, \"-\", as.character(viz_data$date))\n\n# Create a unique identifier for each show\nviz_data$show_id <- seq_len(nrow(viz_data))\n\n# Convert city_date to a factor based on the original order in viz_data\nviz_data$city_date <- factor(viz_data$city_date, levels = unique(viz_data$city_date[viz_data$show_id]))\n\n# Create main plot\nmain_plot <- ggplot(viz_data, aes(x = position, y = city_date)) +\n  geom_tile(aes(fill = song_title), color = \"grey90\", linewidth = 0.5) +\n  geom_text(aes(label = ifelse(is_gap, \"\", four_letter_code)), \n            size = 1.5,\n            color = \"white\") +\n  scale_fill_manual(values = song_colors) +\n  theme_minimal() +\n  theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 7),\n        axis.text.y = element_text(size = 8),\n        plot.title = element_text(size = 12, hjust = 0.5),\n        plot.subtitle = element_text(size = 10, hjust = 0.5),\n        legend.position = \"none\",\n        panel.grid = element_blank()) +\n  labs(x = \"Song Position\", y = \"City - Show Date\",\n       title = paste(\"Setlist Alignment for\", tour_name),\n       subtitle = paste(\"Showing\", num_setlists, \"most representative setlists. Empty white cells indicate inserted/skipped songs\")\n  )\n\n# Create legend plot\nlegend_plot <- ggplot() +\n  geom_text(aes(x = 0.5, y = 0.5, label = str_wrap(legend_text, width = 250)), \n           size = 2, hjust = 0.5) +\n  theme_void() + \n  theme(plot.margin = margin(t = 10))\n\n# Arrange plots together\ngrid.arrange(main_plot,\n             legend_plot,\n             ncol = 1,\n             heights = c(4, 1))\n\n```\n\n## Multiple Setlist Alignment with MAFFT\n\nI was not satisfied with the resulting alignments shown above, produced with the custom alignment code based on the Needleman-Wunsch algorithm. While exploring alternatives I discovered that the [@Katoh2002]MAFFT algorithm for multiple sequence alignment has an option '--text' mode that can calculate and create multiple sequence alignments for non-biological sequences (see [this page](https://mafft.cbrc.jp/alignment/software/textcomparison.html) from the MAFFT authors). In the R package ips there is a [mafft wrapper function](https://search.r-project.org/CRAN/refmans/ips/html/mafft.html), so I installed and tried it out. However, this R implementation of mafft does not allow for the `--text` mode. Hence, I implemented the solution using both R and the command line version of mafft on my Mac. I could also wrap the command line actions and execute it from R, but I did not spend time on that, mainly because it would still create a challenging dependency in my R-package.\n\n```{r data analysis - tour setlist alignment MAFFT, warning=FALSE, message=FALSE, error=FALSE}\n\n# Filter for specific tour\ntour_data <- u2data[u2data$tour == \"U2 Vertigo Tour\", ]\n# Remove snippets\nno_snippets_data <- concertData_remove_snippets(tour_data)\n# Remove shows with no setlist \nfiltered_data <- concertData_remove_showsNoSetlist(no_snippets_data)\n\n# Process the songs to create the mapping of codes\ncodes_tour_songs <- codify_tour_song_titles(filtered_data)\n\n# Prepare all setlist sequences\nall_setlist_sequences <- prepare_setlist_sequences(filtered_data, codes_tour_songs)\n\n# Find the most representative setlists\nrepresentative_setlists <- find_most_representative_setlists(all_setlist_sequences, n_representatives = 30)\n\n# Create fasta-format sequences representing the set-lists of the representative shows\nfasta_mafft_output <- create_setlist_fasta_mafft(representative_setlists)\nwriteLines(fasta_mafft_output, \"mafft/u2_setlists.hex\")\n\n```\n\nNow we have the FASTA-like file with hex values that we can use as input for the multiple sequence alignment algorithm MAFFT. See explanation for this text mode version (non-biological sequences alignment) at: https://mafft.cbrc.jp/alignment/software/textcomparison.html\n\nFollowing the flow explained there, we convert the HEX file to ASCII code using the hex2mafftext command:\n\n``` bash\nhex2maffttext u2_setlists.hex > u2_setlists.ASCII\n```\n\nThe resulting file looks like:\n\n```         \nhead u2_setlists.ASCII\n>showID1392\n,Q9R87,HL9M8CKVJMNf8I^_\n>showID1408\n,Q9NM7,HL9M8CKVJROf8I^_\n>showID1328\n,Q9E87,HL9M8CKVJG7f8I^_\n>showID1320\n,Q9887,HL9M8CKVJGYf8I^_\n>showID1325\n,Q9E87,HL9M8CKVJROf8I+^_\n```\n\nThen we run the actual multiple sequence alignment with the command:\n\n``` bash\nmafft --text --clustalout u2_setlists.ASCII > u2_setlists_mafft_alignment.ASCII\n```\n\nThe output of the run:\n\n```         \nnthread = 0\nnthreadpair = 0\nnthreadtb = 0\nppenalty_ex = 0\nstacksize: 8192 kb\nnalphabets = 256\nGap Penalty = -1.53, +0.00, +0.00\n\n\n\nMaking a distance matrix ..\n    1 / 30\ndone.\n\nConstructing a UPGMA tree (efffree=0) ... \n   20 / 30\ndone.\n\nProgressive alignment 1/2... \nSTEP    20 / 29  d\nReallocating..done. *alloclen = 1048\nSTEP    29 / 29  h\ndone.\n\nMaking a distance matrix from msa.. \n    0 / 30\ndone.\n\nConstructing a UPGMA tree (efffree=1) ... \n   20 / 30\ndone.\n\nProgressive alignment 2/2... \nSTEP    28 / 29  d\nReallocating..done. *alloclen = 1048\nSTEP    29 / 29  h\ndone.\n\ndisttbfast (text) Version 7.526\nalg=A, model=Extended, 1.53, -0.00, -0.00, noshift, amax=0.0\n0 thread(s)\n\n\nStrategy:\n NW-NS-2 (Fast but rough)\n Progressive method (guide trees were built 2 times.)\n\nIf unsure which option to use, try 'mafft --auto input > output'.\nFor more information, see 'mafft --help', 'mafft --man' and the mafft page.\n\nThe default gap scoring scheme has been changed in version 7.110 (2013 Oct).\nIt tends to insert more gaps into gap-rich regions than previous versions.\nTo disable this change, add the --leavegappyregion option\n```\n\nThe output sequence alignment file looks like this:\n\n```         \nmore u2_setlists_mafft_alignment.ASCII\nCLUSTAL format alignment by MAFFT NW-NS-2 (v7.526)\n\n\nshowID1392      -,Q9R-87,HL9M8CKVJMN-f8I^_-\nshowID1408      -,Q9N-M7,HL9M8CKVJRO-f8I^_-\nshowID1328      -,Q9E-87,HL9M8CKVJG7-f8I^_-\nshowID1320      -,Q98-87,HL9M8CKVJ-GYf8I^_-\nshowID1325      -,Q9E-87,HL9M8CKVJRO-f8I+^_\nshowID1299      -,Q9D-8,-HL9M8\\KVJRO-Nf8^_-\nshowID1286      -,Q9R-88,HL9M8\\KVJRO-N8^_--\nshowID1282      -,Q9R-8,-HL9M8\\KVJRO-N8^_--\nshowID1339      -,Q9E--7,UL9M8CKVJMN-f7I^_-\nshowID1412      -,Q9D--7,UL9M8CKVJMN-f7I^_-\nshowID1327      -,Q9E-87,HL9M8CKVJ(--f8^_--\nshowID1271      QE899-,7,HL9M8CKVJRO-f8^_--\nshowID1267      QE899-,7,HL9M8CKVJRO-f8Q--\nshowID1269      QE899-,7,HL9M8CKVJRO-f8Q--\nshowID1270      QE899-,7,HL9M8CKVJRO-f8Q--\nshowID1393      -,Q9E-87,UL9M8CKVJMO-f8\\+-\nshowID1321      -,Q98-87,HL9M8CKVJLGYf8I^_-\nshowID1331      -,Q9E887,HL9M8CKVJ\\7-f8I^_-\nshowID1330      -,Q9E-87,HL9M8CKVJG7Bf8I^_-\nshowID1336      -,Q9N-M7,HL9M8CKVJ7Y-f8I^_-\nshowID1329      -,Q9-8@7,HL9M8CKVJ\\Y-f8+--\nshowID1259      QE89,-77,HL9M8CKVJRO-f8Q--\nshowID1266      QE899-,7,HL9M8CKVJRO-f8BQ-\nshowID1289      QE899-,7,HL9M8CKVJRO-f8BQ-\nshowID1435      -,Q9E--9,DL9M8CKVJON-f8%:-\nshowID1281      -,Q9R-8,9HL9M8\\KVJRO-N8^_--\nshowID1305      -,Q9R-8,9HL9M8\\KVJRO-N8^_--\nshowID1436      -,Q9E-9,7%L9M8CKVJRO-f82:-\nshowID1322      -,Q988F7,HL9M8CKVJG7-f8^_--\nshowID1284      -,Q9D-8,-HL9M8\\KVJRO-N87+-\n                   *      **** ***        \n```\n\nNow we can visualize this multiple set list alignment.\n\n```{r data analysis - tour setlist alignment MAFFT - plot, warning=FALSE, message=FALSE, error=FALSE}\n\n# libraries\nlibrary(dplyr)\nlibrary(stringr)\n\n# Get a data frame from the mafft clustal output\nalignment_data <- read_mafft_clustal_alignment(\"mafft/u2_setlists_mafft_alignment.ASCII\")\n\n# get number of shows in the alignment\nnum_setlists <- length(unique(alignment_data$showID))\n\n# Mapping the sequence characters to the tour_song_codes\nsong_code_lookup <- codes_tour_songs[, c(\"hex_char\", \"four_letter_code\", \"song_title\")]\n\n# create vizualisation data object\nviz_data <- create_setlist_viz_data(alignment_data, song_code_lookup, filtered_data)\n\n# Create legend for acronyms/short titles\nlegend_data <- viz_data[!viz_data$is_gap, c(\"song_title\", \"four_letter_code\")]\nlegend_data <- unique(legend_data)\nlegend_data <- legend_data[order(legend_data$song_title), ]\nlegend_text <- paste(legend_data$four_letter_code, \"=\", legend_data$song_title, collapse = \", \")\n\n# Create custom color scale that uses distinct colors for songs and white for gaps\nn_songs <- length(unique(viz_data$song_title[!viz_data$is_gap]))\nsong_colors <- create_distinct_palette(n_songs)\nnames(song_colors) <- unique(viz_data$song_title[!viz_data$is_gap])\nsong_colors <- c(song_colors, GAP = \"white\")\n\n# Get the tour name from filtered_data\n# Get a single showID from alignment_data\nsample_showID <- alignment_data$showID[1]\n# Lookup the tour_name in filtered_data\ntour_name <- unique(filtered_data$tour[filtered_data$showID == sample_showID])\n\n# plot the multiple sequence alignment of the tour setlists\n# load library\nlibrary(ggplot2)\nlibrary(gridExtra)\n\n# Create a new column combining city and date\nviz_data$city_date <- paste(viz_data$city, \"-\", as.character(viz_data$date))\n\n# Create a unique identifier for each show\nviz_data$show_id <- seq_len(nrow(viz_data))\n\n# Convert city_date to a factor based on the original order in viz_data\nviz_data$city_date <- factor(viz_data$city_date, levels = unique(viz_data$city_date[viz_data$show_id]))\n\n# Create main plot\nmain_plot <- ggplot(viz_data, aes(x = position, y = city_date)) +\n  geom_tile(aes(fill = song_title), color = \"grey90\", linewidth = 0.5) +\n  geom_text(aes(label = ifelse(is_gap, \"\", four_letter_code)), \n            size = 1.5,\n            color = \"white\") +\n  scale_fill_manual(values = song_colors) +\n  theme_minimal() +\n  theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 7),\n        axis.text.y = element_text(size = 8),\n        plot.title = element_text(size = 12, hjust = 0.5),\n        plot.subtitle = element_text(size = 10, hjust = 0.5),\n        legend.position = \"none\",\n        panel.grid = element_blank()) +\n  labs(x = \"Song Position\", y = \"City - Show Date\",\n       title = paste(\"Setlist Alignment for\", tour_name),\n       subtitle = paste(\"Showing\", num_setlists, \"most representative setlists. Empty white cells indicate inserted/skipped songs\")\n  )\n\n# Create legend plot\nlegend_plot <- ggplot() +\n  geom_text(aes(x = 0.5, y = 0.5, label = str_wrap(legend_text, width = 250)), \n           size = 2, hjust = 0.5) +\n  theme_void() + \n  theme(plot.margin = margin(t = 10))\n\n# Arrange plots together\ngrid.arrange(main_plot,\n             legend_plot,\n             ncol = 1,\n             heights = c(4, 1))\n```\n\n## Distance tree of aligned setlists\n\nAnother way to display the relatedness of setlists is to use a distance tree, often used for biological sequences, producing so called phylogenetic trees.\n\n```{r data analysis - tour setlist distance tree, warning=FALSE, message=FALSE, error=FALSE}\n\nlibrary(dplyr)\nlibrary(seqinr)\nlibrary(ape)\nlibrary(ggplot2)\nlibrary(ggtree)\n\n# Get a data frame from the mafft clustal output\nalignment_data <- read_mafft_clustal_alignment(\"mafft/u2_setlists_mafft_alignment.ASCII\")\n# Convert data frame to list which is needed for downstream distance tree analysis\nsequences <- setNames(as.list(alignment_data$sequence), paste0(\"showID\", alignment_data$showID))\n\n# Calculate distance matrix\ndist_matrix <- calculate_distance_matrix(sequences)\n# Convert to dist object\nsetlist_dist <- as.dist(dist_matrix)\n# Construct the tree\nsetlist_tree <- nj(setlist_dist)\n\n# Collect show info\nshow_info <- unique(filtered_data[, c(\"showID\", \"city\", \"date\", \"country\", \"leg\")])\nshow_info$city_date <- paste(show_info$city, format(show_info$date, \"%Y-%m-%d\"), sep = \" - \")\n\n# create tree labels in the format 'City YYYY-MM-DD'\nnew_labels <- create_city_date_tree_labels(filtered_data, setlist_tree, show_info)\n# Modify tree labels \nsetlist_tree$tip.label <- new_labels\n\n# create standard tree plot\ntree_plot <- create_ggtree_plot(setlist_tree)\n# Display the plot\nprint(tree_plot)\n\n# Create the tree plot with colors based on country\nplot_country <- create_ggtree_plot_colored(setlist_tree, show_info, color_by = \"country\")\nprint(plot_country)\n\n# Create the tree plot with colors based on leg\nplot_leg <- create_ggtree_plot_colored(setlist_tree, show_info, color_by = \"leg\")\nprint(plot_leg)\n\n```\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["styles.css"],"toc":true,"output-file":"multiple-setlist-alignment.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.6.32","theme":"cosmo","title":"Multiple Setlist Alignment","author":"Hans van Leeuwen","editor":"visual"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}